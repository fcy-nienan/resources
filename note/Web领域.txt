spring事务到底用于service层还是dao层
Spring事务为业务逻辑进行事务管理，保证业务逻辑上数据的原子性。

事务得根据项目性质来细分：事务可以设置到三个层面(dao层、service层和web层)。 
第一：web层事务，这一般是针对那些安全性要求较高的系统来说的。例如电子商务网站。粒度小，一般系统用不着这么细。 
第二：service层事务，这是一常见的事务划分， 将事务设置在业务逻辑上，只要业务逻辑出错或异常就事务回滚。粒度较小，一般推荐这种方式。
第三：数据持久层数据务，也就是常说的数据库事务。这种事务在安全性方面要求低。就是给一个简单的增删改之类的操作增加事务操作。粒度大
给Service层配置事务，因为一个Service层方法操作可以关联到多个DAO的操作。在Service层执行这些Dao操作，多DAO操作有失败全部回滚，成功则全部提交。
事务分为业务事务和系统事务，业务事务也就是业务逻辑上操作的一致性，系统事务自然就是指真正的数据库事务，
Spring配置事务的是为了什么进行管理，当然是为业务逻辑进行事务管理，保证业务逻辑上数据的原子性；
Dao层是什么，数据访问层，是不应该包含业务逻辑的，这就是和Service层的不同；
Service层就是业务逻辑层，事务的管理就是为Service层上的保证


1）正常的http url请求，只有浏览器和服务器两个参与者。浏览器端发起一个http请求，服务器端处理后发起一个重定向，浏览器端从response中获取到重定向地址，发起另一个http url请求。也就是说，浏览器会按照response中的内容进行响应（如重定向），这是浏览器的功能决定的就得响应。 
2）Ajax请求，参与者就有三个即ajax、客户端、服务器，ajax处于客户端和服务器两者之间。过程是客户端发起一个ajax请求，服务器端处理后，如果发起一个重定向，然后ajax会怎么办呢？它只会获取刚才请求返回的数据，其他的任何动作一概不去做，ajax是这么做的（ajax功能就是这么设定的，ajax框架源代码也是这么写的）。 
也就是说，引入了ajax之后，ajax就插在浏览器和服务器之间了，服务器给浏览器的response被ajax拦截了，但是ajax本身却什么都不做，也不转达。





事务得跟据项目性质来细分：事务可以设置到三个层面，也不仅仅是楼主提到的那两种。
第一：web层事务，这一般是针对那些安全性要求较高的系统来说的。比例如电子商务网站。粒度小，一般系统用不着这么细。
第二：service层事务，这是一常见的事务划分， 将事业设置在业务逻辑上，只要业务逻辑出错或异常就事务回滚。粒度较小，一般推荐这种方式
第三：数据持久层数据务，也就是常说的数据库事务。这种事务在安全性方面要求低。就是给一个简单的增删改之类的操作增加事务操作。粒度大



首先我们需要分清楚数据和状态。

状态是对数据的抽象。
数据多半不能直接被用户看到（比如你不能直接返回一个timestamp给用户），而状态则更贴近业务；
数据需要是原子的（数据库第一、二范式），而状态一般涉及一条以上的数据；
数据稳定性高，状态变数多：需求变化了，不应该去操作全量数据，而是修改状态控制；
数据适合放在有持久化的地方，而状态根据数据动态算出，适合放在内存中（当然，系统大到出现集群的概念以后，状态也可能需要持久化）。

读
大部分时候，我们需要的都不是裸数据，而是根据数据获得的状态。由数据转化为状态的逻辑总得放在一个端，要么是数据库，要么是后端，在非常少见的情形里，是前端/客户端。

读操作的逻辑放在哪里不那么非黑即白，需要根据具体业务分析。

写
对数据本身的约束可以放在数据库中：


对状态的约束一般在控制在数据的写操作前：

“每天只允许注册 100 个用户”这个需求就创建了“是否今天注册了超过100个用户”的状态

如果对状态的约束全需要放在业务逻辑里，业务逻辑写在哪里呢？
不得不说，业务逻辑使用存储过程/触发器实现有很多很多缺点：

存储过程/触发器异常处理很麻烦，程序流程处理复杂了不说，也难以对异常情形生成友好的错误提示

存储过程/触发器难以断点调试

存储过程/触发器基于关系型数据库，做更加复杂（树状结构等）/ 更加简单（连循环计算都需要一个临时表）的逻辑都有很大损耗

存储过程/触发器杂糅了逻辑在数据库中，业务变大以后难以合理分层

存储过程/触发器使用描述性语言，相对难以优化

因此，几乎没有人把对状态的写操作的相关业务逻辑写在存储过程/触发器里。











防止重复提交

1.在进入提交页面时生成一个时间戳，将该时间戳赋值到一个隐藏域中

2.在请求提交到服务器时，服务器获取客户端提交的这个隐藏域time1,并从session中请求session中保存的前一个请求的时间戳time2，如果两个时间戳都不是空并且相等则说明本次请求为重复提交，抛出错误，否则将本次请求的时间戳更新到session的time2中，用于下次做重复提交判断

 

这样的话无论如何刷新页面，浏览器缓存的时间戳域永远是初次进入提交页面时生成的时间戳

这种方式也可以避免在提交页面连续点击按钮提交请求发生重复提交的问题



FileServer
一个线程扫描目录下的文件并且加入到阻塞队列中
一个线程读取阻塞队列并且将其发送到客户端







数据库连接的一些参数
	初始化连接数是多少?当有连接来临时一个一个的创建连接,当连接到达多少时停止创建连接,
	当停止创建连接后还有新的连接来临时需要等待多少时间,当使用的连接一个一个关闭后可以剩下多少空闲的
	连接

	初始化连接数
	最大连接数
	最大空闲连接数
	最小空闲连接数
	最大等待时间
	空闲连接最大生存时间
	每隔多少时间检查一次空闲的连接
	
	
	
	
	spring注解学习
	@Autowired
		默认按照类型注入,有一个required参数,默认为true,代表当需要的bean不存在的时候报错,如果设置为false,那么当需要的bean不存在的时候不会报错
	@Bean
		有几个属性,bean初始化方法调用,bean销毁方法调用,是否参与自动注入
		
	@Primary
		* Indicates that a bean should be given preference when multiple candidates
		* are qualified to autowire a single-valued dependency. If exactly one
		* 'primary' bean exists among the candidates, it will be the autowired value.
		一个接口有多个实现类的时候,在某一个实现类上加上该注解,标识当其他对象需要改接口的实现类时
		优先使用该对象
	@Qualifier
		一个接口有多个实现类的时候,自动按类型注入会失败,可以使用该注解标识注入哪个类
	@ConfigurationProperties
		可以通过在配置文件中配置一个bean的属性
		配置文件的属性前缀:value
		是否忽略不合格的字段:ignoreInvalidFields
		是否忽略未知的字段:ignoreUnknownFields
	@Scope
		bean的作用域,一般都是单例,原型两种,其他的在web环境下有request,session,globalSession
		