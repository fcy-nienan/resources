设计原则
1找出应用中可能需要变化之处,把他们独立出来,不要和那些不需要变化的代码混在一起
2针对接口编程,而不是针对实现编程
3多用组合,少用继承(Unix的面向函数编程,一个函数只完成一件事,纯函数)(组合,运行时动态扩展,而继承是编译时就确定的)
4为了交互对象之间的松耦合设计而努力
5类应该对扩展开放,对修改关闭(是类,针对的是类)
6要依赖抽象,不要依赖具体类(原则1变量不可以持有具体类的引用2不要让类派生自具体类3不要覆盖基类中已实现的方法)(要尽可能的去遵守这个原则,而不是随时都要遵循)
6最少知识原则(只调用自身对象的方法和所持有引用的对象的方法)(不调用持有引用对象方法返回对象的方法)
7别调用我们,我们会调用你(高层组件有选择性的调用底层组件,调用哪个底层组件和何时调用有高层组价决定)

异常处理原则
延迟处理 自己能处理就自己处理，自己不能处理就叫给上一层处理
catch尽量捕获一种异常类型  细化异常类型
try中只放可能会出现异常的信息

java不会等到把程序中用到的所有类都装载完后才开始运行程序，它只在需要时才装载相应的类



一个对象持有其他对象的引用是正常的,
这样我们才能更好的定义该对象本身的一些行为,专注于该对象本身的特性

代码点和代码单元
代码点是Unicode字符集中的一个数字,该数字被我们认为是某一个汉字
utf-8采用1-4个代码单元对其进行编码,utf-16采用2个代码单元对其进行编码
utf-32采用4个代码单元对其进行编码


计算机的本质是一个状态机，内存里存储的所有数据构成了当前的状态，
CPU只能利用当前的状态计算出下一个状态（不要纠结硬盘之类的外部存储，
就算考虑他们也只是扩大了状态的存储容量而已，
并不能改变下一个状态只能从当前状态计算出来这一条铁律）当你企图使用计算机解决一个问题是，
其实就是在思考如何将这个问题表达成状态（用哪些变量存储哪些数据）以及如何在状态中转移（怎样根据一些变量计算出另一些变量）。
所以所谓的空间复杂度就是为了支持你的计算所必需存储的状态最多有多少，所谓时间复杂度就是从初始状态到达最终状态中间需要多少步！

如果一个算法的执行次数是 T(n)，那么只保留最高次项，同时忽略最高项的系数后得到函数 f(n)，
此时算法的时间复杂度就是 O(f(n))。为了方便描述，下文称此为 大O推导法。



每个阶段只有一个状态->递推；
每个阶段的最优状态都是由上一个阶段的最优状态得到的->贪心；
每个阶段的最优状态是由之前所有阶段的状态的组合得到的->搜索；
每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到而不管之前这个状态是如何得到的->动态规划。


加密和编码的区别

编码是对数据进行转换的过程，以便它可以在通信信道上无危险地传输，或在存储介质上无危险地存储。
例如，计算机硬件不处理文本，它只是操纵字节，所以文本编码是文本应该如何转换为字节的描述。
同样，HTTP不允许安全传输所有字符，因此可能需要使用base64编码数据（仅使用字母，数字和两个安全字符）。

编码或解码时，重点放在每个人都有相同的算法，该算法通常是有据可查的，分布广泛和相当容易实现。任何人最终都能够解码编码数据。

另一方面，加密对一部分数据进行了转换，只能通过对如何解密该数据的特定（和秘密）知识进行逆转。
重点是让除预期收件人以外的任何人都难以阅读原始数据。保密的编码算法是一种加密方式，
但是非常脆弱（需要花费技巧和时间来设计任何类型的加密，
根据定义，您不能让其他人为您创建这样的编码算法 - 否则必须杀死他们）。
相反，最常用的加密方法使用密钥：算法是众所周知的，但加密和解密过程要求两个操作具有相同的密钥，然后密钥保密。
解密加密数据只能通过相应的密钥进行。


遍历过程中需要修改数据怎么办
设置一个变量,每次修改的时候更新该变量的值,规定遍历的时候需要比较该值是否与刚开始遍历的时候的值相等,如果不相等则
抛出异常,这就是快速失败

java并发包下的安全失败也没有好到哪里去,遍历的时候他会从原始数据复制一份,然后在复制的这份数据上遍历,
并且遍历期间如果有其他线程修改了原始数据,遍历时是看不到的,因为遍历是用的是最开始复制的那一份,有点像
写时复制


volatile关键字,可见性和有序性,有序是因为CPU会乱序执行指令,而有些多线程的程序不同的推进顺序会造成不同的结果,所以此时需要CPU按照我们的意愿来运行
可见性,现在的CPU是多个核,每个核都有自己的缓存,一级二级三级,当某个当CPU更新一个缓存中的变量的时候其他CPU并不能得到相应的通知,所以其他CPU并不能看到改变量的新值,然后出现了MESI协议,这个协议规定了CPU缓存间如何保持一致性,
通过四种状态,M修改,E独占,S共享,I失效,一个变量进入CPU缓存首先是E状态,如果另一个核也加载了改变了,则都变成S状态,
当其中一个核修改了改变量后,他首先通知其他CPU置为无效状态,然后等待返回结果,然后修改自己CPU的位M状态
,然后写回到主存,