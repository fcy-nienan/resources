设计模式
代理模式:
		静态代理
		代理类持有一个主题对象接口的引用
		代理类通过主题对象来实例化
		然后通过调用代理类的方法来调用主题对象的方法
		动态代理
		AOP
		代理类在每次调用主题的方法之前可以加一些自己的代码
		XiangQinInterface proxy = (XiangQinInterface) Proxy.newProxyInstance(  
                zhangSan.getClass().getClassLoader(),  类加载器
                zhangSan.getClass().getInterfaces(),   类所有接口
                new ReadyInvocationHandler(zhangSan));  动态代理类
        proxy.xiangQin(); 
		InvocationHandler接口
		public Object invoke(Object proxy,Method method,Object[] args){
		
		}
		
		newProxyInstance方法返回的是一类名叫$Proxy0 extends Proxy implements XiangQinInterface的类
		然后将这个类
策略模式							    
	定义了算法簇,分别封装起来,让他们可以互相替换,此模式让算法的变化独立于使用算法的客户
观察者模式
	在对象之间定义一对多的依赖,这样一来,当一个对象改变状态,依赖它的对象都会收到通知,并自动更新
	观察者的代表人物----MVC
	事件源    事件发生的地方,持有所有监听器的引用,有一个监听器引用的列表
	事件对象  事件的表示方法,一个对象,用字符串表示事件状态,并持有一个事件源的引用
	监听器	  处理事件的对象,事件源发出的事件对象对应一个不同的处理过程
	
	事件对象时事件源推还是监听器自己取出来?
	各有优点
	监听器也可以持有某个事件源的引用
装饰者模式
		动态地将责任附加到对象上,若要扩展功能,装饰者提供比继承更有弹性的替代方案
工厂模式

		简单工厂:抽象产品  具体产品  具体工厂
		工厂模式:抽象产品  具体产品  抽象工厂  具体工厂
		抽象工厂:抽象产品  具体产品  抽象工厂  具体工厂(这里有几个抽象产品就有几个抽象工厂)
		三者的区别在于产品的多少,多有多个产品时就相应的变化
		具体做法是使用简单工厂配合反射来实现
单例模式
		一个类在程序运行期间只产生一个实例
		方法  静态变量
			  getInstance()方法
			  私有构造方法
		注意事项:
		线程安全?
		是否只在需要时才第一次创建?
		性能问题和安全问题
		public static getInstance(){
			if(object==null){
				synchronized(object.clsaa){
					if(object==null){
						object=new object();
					}
				}	
			}
			return object;
		}
命令模式
		发出者  命令对象  接受者
		发出者:持有命令的引用
		命令对象:持有接受者的引用
		接受者:具有命令对象所对应的方法
		
		撤销操作需要记录先前一步的操作状态
适配器模式
		客户
		适配器
		被适配者
		客户调用适配器的方法来操作被适配的对象
		适配器实现客户接口并持有一个被适配对象的引用
模板方法
		在抽象类中定义一个final方法,方法中依次调用一些抽象方法,而这些抽象方法由子类实现
设计原则
1找出应用中可能需要变化之处,把他们独立出来,不要和那些不需要变化的代码混在一
起
2针对接口编程,而不是针对实现编程
3多用组合,少用继承(Unix的面向函数编程,一个函数只完成一件事,纯函数)(组合,运行时动态扩展,而继承是编译时就确定的)
4为了交互对象之间的松耦合设计而努力
5类应该对扩展开放,对修改关闭(是类,针对的是类)
6要依赖抽象,不要依赖具体类(原则1变量不可以持有具体类的引用2不要让类派生自具体类3不要覆盖基类中已实现的方法)(要尽可能的去遵守这个原则,而不是随时都要遵循)
6最少知识原则(只调用自身对象的方法和所持有引用的对象的方法)(不调用持有引用对象方法返回对象的方法)
7别调用我们,我们会调用你(高层组件有选择性的调用底层组件,调用哪个底层组件和何时调用有高层组价决定)


不同对象有不同的属性,不同对象之间还有相应的行为,可以将这两种分开
同一个对象有属性,还有行为,可以将这两种职责分开

控制反转
    由一个第三方来协调调用者和被调用者的行为
    大部分框架都使用了控制反转技术,当一个框架没有提供控制反转的时候就沦为工具库了
