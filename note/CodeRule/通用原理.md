the world is concurrent
things in the world don't share data
things communicate with messages
things fail
并行,不共享,消息传递,容易失败

以前对一些类中持有一大堆其他类的引用感到很烦,不知道为什么需要这么多
一个对象持有其他对象的引用是正常的,
这样我们才能更好的定义该对象本身的一些行为,专注于该对象本身的特性
# 容错机制
    如果发生了xxx,能不能自动处理
    也就是针对一些可能发生的异常写了相应的处理代码
    
    数据的容错
    数据检查点:执行数据的拷贝过程
    记录数据的更新:只记录哪些数据更新了数据,每条记录的更新都会记录下来


# 数据是什么?
	数据是一堆字节和其定义在其上的操作
    这样的数据才有意义,要不然只有一堆字节的话,在每个人看来都可以有不同的意思
    ,只有其上的操作定义了其才有意义
	在代码中就是定义其变量,然后变为私有的类型,使得其他人不可直接访问该
	变量,而是通过我们自己定义的一些public的方法来访问,只要正确定义了其上
	的操作方法,那么也就定义了其数据的真正含义
	
	那么状态是什么呢？
	状态就是一堆数据的
	
# 抽象和具体实现
    PC程序计数器是一个抽象的概念
    CS:IP寄存器是其具体的实现
    局域网是一个抽象概念
    以太网是其具体实现


硬件错误是常态，因此需要冗余
在计算机中的数据的保存和运算都是以二进制的形式进行的,
但不是直接的原码,
而是原码的补码,也就是说在计算机中,数据的运算都是以数据的补码进行的
	
将一个字符串映射到一个数组中时,你只能得到其指定位置是否存在,但是得不到其映射时的输入顺序

		
什么是锁

在单进程的系统中，当存在多个线程可以同时改变某个变量（可变共享变量）时，就需要对变量或代码块做同步，
使其在修改这种变量时能够线性执行消除并发修改变量。

而同步的本质是通过锁来实现的。为了实现多个线程在一个时刻同一个代码块只能有一个线程可执行，
那么需要在某个地方做个标记，这个标记必须每个线程都能看到，当标记不存在时可以设置该标记，
其余后续线程发现已经有标记了则等待拥有标记的线程结束同步代码块取消标记后再去尝试设置标记。
这个标记可以理解为锁。

不同地方实现锁的方式也不一样，只要能满足所有线程都能看得到标记即可。如java中synchronize是在对象头设置标记，Lock接口的实现类基本上都只是某一个volitile修饰的int型变量其保证灭个线程都能拥有对该int的可见性和原子修改，linux内核中也是利用互斥量或信号量等内存数据做标记。
除了利用内存数据做锁其实任何互斥的都能做锁（只考虑互斥情况），如流水表中流水号与时间结合做幂等校验可以看作是一个不会释放的锁，或者使用某个文件是否存在作为锁等。只需要满足在对标记进行修改能保证原子性和内存可见性即可。


leader和follow模型
假设有n个线程，那么其中一个线程为leader，该线程监听网络，发现连接后负责处理该连接，当该线程处理一个连接时，该线程成为follower，其他的空闲follower通过竞争成为新的leader，这样的好处是避免了线程切换带来的开销。


数据不可能凭空消失,除非你没向外输出
数据不在你认为的地方,那么可能有其他个体对数据进行了操作

表达式和语句的区别
    表达式可以求值
    语句就是一条
使用异常还是返回错误码

如何测试一个数组是否包含指定的值?
    Arrays.asList(...).contains(...)
    使用 Apache Commons Lang包中的ArrayUtils.contains
    自己写逻辑
    如果数组有序(二分查找)
    如果数组无序
    方法很多，但问题的本质只是在给定的数组中查找具体的值
    相等的判断条件？
    不同语言提供的API不同写的方式自然也不同，风格不一样
    至于简单和优雅只是将搜索功能封装了而已，然后只要调用相应的函数就行
在数据层面OO和FP有什么区别?
OO
    数据和数据操作是紧耦合的
    核心是数据,然后基于数据构建相应的模型
FP
    数据和数据操作是松耦合的
    核心是函数,不是数据
OO以数据作为核心
FP以函数作为核心

OO需要我们一步一步指定怎么做
FP只需要我们想好我们需要什么,然后通过组合函数自己玩去
# 表驱动法
>表驱动法是一种编程模式,从表里面查询信息而不使用逻辑语句(如if或switch)  
事实上凡是能使用逻辑语句解决的问题都可以通过查表解决,但当逻辑嵌套越深时,我们理解和整理起来就越发吃力
* 通过逻辑来解决相当于多使用我们的大脑,
而通过查表解决相当于我们将数据都写在了书上,也就是相当于一个CPU和内存的权衡
,多使用CPU还是多使用内存.
* 表驱动法是什么
* 不使用表驱动法有什么问题?(也就是传统的写法有啥劣势)
* 表驱动法如何写?(怎么做)
    直接访问
    索引访问(哈希)
    阶梯访问(范围记录)
* 优势
    + 可以将表里面的数据存放在外部存储中,这样也就代表这我们可以在不改变程序的情况下调控一些参数
# 数据驱动编程
>更普遍的是，战略上突破常来自数据或表的重新表达――这是程序的核心所在。如果提供了程序流程图，
而没有表数据，我仍然会很迷惑。而给我看表数据，往往就不再需要流程图，程序结构是非常清晰的。
由于缺乏空间而绞尽脑汁的编程人员，常常能通过从自己的代码中挣脱出来，回顾、分析实际情况，
仔细考虑程序的数据，最终获得非常好的结果。实际上，数据的表现形式是编程的根本，

数据驱动编程的核心出发点是相对于程序逻辑，人类更擅长于处理数据。数据比程序逻辑更容易驾驭，所以我们应该尽可能的将设计的复杂度从程序代码转移至数据

数据压倒一切。如果选择了正确的数据结构并把一切组织的井井有条，正确的算法就不言自明。编程的核心是数据结构，而不是算法