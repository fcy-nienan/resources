# 记录
+ 在方法中加入一些调试代码输出被调用时的状态
# 代码大全
+ 参数检测时需要考虑最小和最大,多考虑边界检查
+ 参数顺序控制:状态变量和布尔变量放在最后面
+ 不要把参数当作工作变量
+ 把传入子程序的参数用作工作变量是非常危险的
+ 通向的技术也被用于保持全局变量的值
+ 如果你需要为全局变量计算一个新值,那应该在计算的最后把最终值赋给全局变量,而不要把中间值赋给他
# 防御性编程和契约型编程
* 防御性编程时内部自己处理,保证代码的健壮性,也就是可以认为穿了一些模棱两个的参数自己控制
将其变为一个相似的参数还是向外部抛出错误,重点在于如何处理不规范的参数
* 而契约式编程是只接受符合规范的参数,其余参数一律不执行,重点在于只接受合格的参数
```
    public void run() {
        if (state != NEW ||
            !UNSAFE.compareAndSwapObject(this, runnerOffset,
                                         null, Thread.currentThread()))
            return;
        try {
            Callable<V> c = callable;//这里为什么需要使用一个局部变量,而不是直接使用callable这个成员变量
            //这样做有什么好处,或者还说是为了防止一些其他方面的影响,或者只是一种习惯,亦或者随意
            //上面这种写法有三条指令
                             //ALOAD 0
                             //GETFIELD java/util/concurrent/FutureTask.callable : Ljava/util/concurrent/Callable;
                             //ASTORE 1
            /*
            2020/1/17:工作变量,这样当callable被赋值其他值的时候c引用的还是原先那个,这样更好
            */
            if (c != null && state == NEW) {
                V result;
                boolean ran;
                try {
                    result = c.call();
                    ran = true;
                } catch (Throwable ex) {
                    result = null;
                    ran = false;
                    setException(ex);
                }
                if (ran)
                    set(result);
            }
        } finally {
            // runner must be non-null until state is settled to
            // prevent concurrent calls to run()
            runner = null;
            // state must be re-read after nulling runner to prevent
            // leaked interrupts
            int s = state;
            if (s >= INTERRUPTING)
                handlePossibleCancellationInterrupt(s);
        }
    }
```
>下面部分代码来源:https://github.com/apache/spark/pull/4703/files
1. 定义的返回值
    code message success data
    代码  信息  成功或者失败  数据
2. 日志打印警告信息
    WARNING: /base/bigData/hadoop/logs does not exist. Creating
3. 使用别人的程序尽量不适用系统的默认值,也就是多花时间去了解相应的参数是啥意思
4. 尽量按照可读性来书写代码,下面的代码中第二行比第一行可读性要好多了
``` 
    -    while (!waitingForVisit.isEmpty) {
    +   while (waitingForVisit.nonEmpty) {
```
5. 能换行的尽量换行,增加可读性,下面的foreach中虽然只有一行代码,但也需要换行
```
  private[scheduler] def handleTaskSetFailed(taskSet: TaskSet, reason: String) {
-    stageIdToStage.get(taskSet.stageId).foreach {abortStage(_, reason) }
+    stageIdToStage.get(taskSet.stageId).foreach {
+      abortStage(_, reason)
+    }    
     submitWaitingStages()
  }
```
# 使用布尔变量还是通过hash方法获取到数据
比如有一个功能是:
上传不同类型的文件,有的文件需要校验表头,有的不需要校验表头
校验表头的方法又不一致
将每个文件类型的校验方法放在一个Map中,K=文件类型,V=对于的方法或者类(通过反射调用)
这个时候我是在另外定义一个布尔变量verify
    boolean verify=true
    Map<String,Timer> timerMap=new HashMap();
    if(clear){
        Timer timer=timerMap.get(fileType);
    }
还是直接在代码中通过map的null来
    if(timerMap(fileType)!=null){
        
    }
# 文件命名规则
上传文件类型:xxx.xlsx或者xxx.xls
A-id-dataChannel-companyName-branchName-sectionNode(.xls|.xlsx)
A-id-(.xls|.xlsx)
C-id-(.xls|.xlsx)
上传文件大小
是否校验表格头
校验表格头的方法(不同的文件校验的方法不同)
是否转换txt(转换的方法是一样的,只是提供的参数不同)

第一次重构
将可变的数据提取出来
A
有的需要dataChannel后面的数据有的不需要
上传文件大小
是否需要校验表格头
校验的方法
是否转换txt
转换的方法
