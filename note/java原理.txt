虚拟机运行的时候,运行时常量池会保存大量的符号引用，这些符号引用可以看成是每个方法的间接引用。如果代表栈帧A的方法想调用代表栈帧B的方法，那么这个虚拟机的方法调用指令就会以B方法的符号引用作为参数，但是因为符号引用并不是直接指向代表B方法的内存位置，所以在调用之前还必须要将符号引用转换为直接引用，然后通过直接引用才可以访问到真正的方法。

如果符号引用是在类加载阶段或者第一次使用的时候转化为直接应用，那么这种转换成为静态解析，如果是在运行期间转换为直接引用，那么这种转换就成为动态连接

java垃圾回收机制
	什么样的对象可以被回收？
	最简单的是通过引用计数方式，但引用计数方式无法解决循环引用的问题
	所以后来通过GC Root，通过一些root对象一直遍历下去，能够遍历的就认为能够存活，无法遍历到的就认为可以回收
	并不是通过收集不可用的对象来清除，而是通过收集可用的对象然后清除其他
GCroot哪些是根对象呢？
	1、栈中引用的对象
	2、static静态变量
		静态方法和变量不产生实例，直接由类引用。Java的类由java.lang.ClassLoader类加载器加载，
		类的数据都不在逻辑堆，
		而是存在永生代，也就是Method Area方法区，现在叫Metaspace。类本身一旦被GC清除，他的所有静态变量
		也就跟着被释放了。
	3、main线程
		main方法就是一个thread线程。java里线程也都是继承自基类，所以自身也是一个大实例。
	4、JNI
		JNI是支持其他编程语言的本机码和Java字节码互相调用的程序。除了Java进程内部的调用，
		JVM还需要知道一个实例是否被外部本机代码所调用，JNI引用就列举了当前的外部调用。


java垃圾回收算法


1、标记清除
	也就是每次GC，会先扫描内存区标记存活对象，而后释放未被标记的对象空间。这种算法在工作时需要停止工作线程，再进行标记清除，同时会产生内存碎片，而且jvm需要维护一个内存空间表，用于分配内存空间。 
2、标记整理
	标记阶段与标记清除算法一样。但后续并不是直接对可回收的对象进行清理，而是让所有存活对象都想一端移动，然后清理。优点是不会造成内存碎片。
3、复制算法
	将内存区域分为两部分，回收的时候将存活的对象复制到另一块内存中(排列紧密，无内存碎片)，然后转换逻辑角色
	再次回收的时候同时也对上一次存活的对象再次进行GCRoot，然后又复制到另一块内存区域，如此循环
4、分代算法
	内存区域分为两个区域:年轻代和老年代
	年轻代有分为三个部分:Eden   from    to
		新创建的对象放在Eden去
		使用回收算法进行回收(copying算法)，将Eden中存活的内容复制到from区
		第二次回收的时候将Eden区和from区的内容复制到to区，再清除Eden区和from区的内容
		然后进行from区和to区进行逻辑上的转换(from区变为to区，to区变为from区)
		再次回收的时候Eden区总是存在的，而from区也总是有对象的，回收的时候Eden区和from区总是需要进行
		GCRoot的，将无法引用到的对象剔除掉(没被引用到旧不复制)
		
5、CMS算法


引用计数法和可达性分析
引用计数法是为对象分配一个变量,每次当有其他变量引用该对象时就加一,如果为0则该对象需要被回收,会造成循环引用,
比如A引用B,B也引用A,这两个对象相互引用,而且该计数也都是1,那么这两个对象都不会回收
可达性分析是通过一系列的GCRoot,从这些对象一直向下搜索,他并不是搜索需要被回收的对象,而是搜索还能存活的对象,然后将这些对象放入sp1区,使用copy算法




java对象存储

对象头
成员变量
对其填充