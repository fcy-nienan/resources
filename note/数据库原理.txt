
mysql的autocommit属性
查看该属性	show variables like '%autocommit%';
改变量可取的值:0|1
默认值为ON,代表1

0		手动提交
		相当于自动执行了start transaction命令,需要用户手动执行commit命令
		若不执行则默认回滚事务
1		自动提交
		如果没有显示地执行start transaction命令,则默认为一条语句一个事务
		如果显示地执行了start transaction命令,则需要手动执行commit命令
		
	也就是有三种情况:	系统自动执行了start transaction命令
						用户手动执行start transaction命令
						用户不执行start transaction命令
						第一种和第三种都是不用执行start transaction命令的
						第一种需要执行commit命令


With the GLOBAL keyword:
	The statement applies globally for all subsequent sessions
	Existing sessions are unaffected.
	
	设置事务的方法
	
	默认		当前session的下一个事务
	Global		当前session后的所有session
	Session		当前session的所有事务
	多事务可能出现的问题
	
	脏读
		一个事务读取了另一个事务未提交的数据
			说明一个事务在修改事务的时候竟然其他事务还可以读取
			那么需要在修改数据的时候加上锁,阻止其他事务读取和修改该数据
	不可重复读
		一个事务在两次读取的时候读取到了不同的数据
			说明两次读取的时候有其他事务改动了改数据
			那么解决办法就是读取的时候锁定改行,只允许其他事务读取而不允许
			其他事务修改
	幻读
		一个事务两次读取的数据不同,不过这是因为插入和删除数据引起的
			只能锁表了,不过mysql是通过mvvc解决的,多版本并发控制
	
	事务的隔离级别
	读提交
	可重复读
	序列化
	
	不同的事务级别是通过使用不同组合的锁来实现的
	行锁
	表锁

	共享锁
	独占锁

	乐观锁
	悲观锁
	

	select执行顺序
	
	from where  group By   having   select   distinct   union   order by
	
FORM: 对FROM的左边的表和右边的表计算笛卡尔积。产生虚表VT1
ON: 对虚表VT1进行ON筛选，只有那些符合<join-condition>的行才会被记录在虚表VT2中。
JOIN： 如果指定了OUTER JOIN（比如left join、 right join），那么保留表中未匹配的行就会作为外部行添加到虚拟表VT2中，产生虚拟表VT3, rug from子句中包含两个以上的表的话，那么就会对上一个join连接产生的结果VT3和下一个表重复执行步骤1~3这三个步骤，一直到处理完所有的表为止。
WHERE： 对虚拟表VT3进行WHERE条件过滤。只有符合<where-condition>的记录才会被插入到虚拟表VT4中。
GROUP BY: 根据group by子句中的列，对VT4中的记录进行分组操作，产生VT5.
CUBE | ROLLUP: 对表VT5进行cube或者rollup操作，产生表VT6.
HAVING： 对虚拟表VT6应用having过滤，只有符合<having-condition>的记录才会被 插入到虚拟表VT7中。
SELECT： 执行select操作，选择指定的列，插入到虚拟表VT8中。
DISTINCT： 对VT8中的记录进行去重。产生虚拟表VT9.
ORDER BY: 将虚拟表VT9中的记录按照<order_by_list>进行排序操作，产生虚拟表VT10.
LIMIT：取出指定行的记录，产生虚拟表VT11, 并将结果返回。   


.from后面的表关联，是自右向左解析的 
而where条件的解析顺序是自下而上的。 
 
也就是说，在写SQL文的时候，尽量把数据量大的表放在最右边来进行关联， 
而把能筛选出大量数据的条件放在where语句的最下面。
group by--执行顺序从左往右分组
from    on    join    where    group by     having    select   distinct

where中的逻辑运算符执行顺序   not>and>or

select * from table where  条件1 AND 条件2 OR 条件3

等价于

select * from table where  ( 条件1 AND 条件2 )  OR 条件3



select * from table where  条件1 AND  条件2 OR 条件3 AND 条件4

等价于

select * from table where   (  条件1 AND  条件2  )  OR   (  条件3 AND 条件4  ) 




spring事务传播行为

传播的是什么？
传播的是JDBC的Connection，JDBC的事务是和Connection挂钩的，两个方法之间是共享同一个Connection还是各自创建自己的，或者抛出异常等等，通过以下参数设置

六种事务传播行为
PROPAGATION_REQUIRES_NEW
	每次都新建一个
PROPAGATION_REQUIRED
	支持当前事务，没有则新创建一个
PROPAGATION_SUPPORTS
	支持当前事务，没有以非事务方式运行
PROPAGATION_MANDATORY
	支持当前事务，只能在已存在的事务中运行,没有抛出异常
	
PROPAGATION_NOT_SUPPORTED
	不支持当前事务，有以非事务方式运行
PROPAGATION_NEVER
	不支持当前事务，如果外部有事务则抛出异常
PROPAGATION_NESTED
	不支持当前事务，有的话另开一个子事务(保存点)

支持当前事务，没有的话则
	新建
	抛出异常
	非事务
不支持当前事务，有的话则
	抛出异常
	非事务
	子事务
每次都新建一个事务


数据库连接池参数
最大连接
最大活动连接
最大空闲




数据库的事务隔离级别
首先说明,事务的隔离级别是通过数据库提供的几种锁来实现的
	读未提交
		该模式下一个事务可以读取另一个事务还未提交的数据,也就是说,底层实现并没有用锁
		该模式可能引发的问题:读取了另一个事务未提交的数据,造成脏读
	读已提交
		该模式下一个事务只能读取另一个事务已经提交了的数据
		该模式解决了脏读,但是又引发了另一个问题,不可重复读,
	可重复读
		该模式下一个事务读取的
	
	
数据库中的锁
	行锁
	表锁
	
	共享锁	所有事务只能读取不能修改
	独占锁	自己可以读取和修改,其他不能读取和修改
	
	数据库事务
		如果事务之间不进行一定的限制,则可能会发生一些问题
			脏读	一个事务读取了另一个事务未提交的数据
				

				
	缓存写机制
		write through
			更新缓存的时候同时更新主存中的数据
		post  write
			更新缓存的时候不直接写入,而是放入更新缓存区中,某时刻更新
		write back
			更新缓存只是将缓存标记一下,再缓存区要被新进入的数据
			取代的时候才更新一下memory
			
			
			
			
			
			