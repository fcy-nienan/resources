Random.nextInt(20) 生成0-19的随机数([0,19]不包括20)

Java的每个方法有张异常表
异常造成的性能消耗很小

java中的int转byte是直接取int值的最后八位,不带符号位
int 129= 00000000 00000000 00000000 10000001
int x=(byte)(129)= 10000001 减一 10000000 取反 01111111 等于-127
那byte自动补位成为int类型呢?
这个是按byte值的符号位扩展的
这样能保证十进制时运算时正确的
但是有时我并不需要十进制的值
可以通过0xff保持高位的值为0,低位的值不变,保证了二进制转换的一致性

自动类型转换
    所有长度低于int的类型在运算结束后结果会被提升为int类型
    当编译器明确知道整数的运算结果没有到达int的表示范围时，byte、short或char类型的运算结果不会被自动提升为int类型
    byte b=127;
    byte c=126+1;
    byte d=b+c;//报错

int x=129&0xff 其中的0xff是char类型
用DataOutputStream写数据到文件乱码?
    文本文件中显示的时ASCII值,而我们向文件中写入的是二进制值
    3的二进制是00000000 00000000 00000000 00000011
    如果将每个byte翻译成ASCII码就会乱码了

String s=s+x 会被替换成 s = (new StringBuilder()).append(s).append(k).toString();这种形式

getDeclaredFields()和getFields()
前者获取本类的所有字段(包括private,protected,publicgit fetch fcy develop:tmp
)
后者获取本类以及父类的所有public字段

File类的separator,separatorChar,pathSeparator,pathSeparatorChar
separator是单个路径中不同父子目录中的分隔符,linux is '/' and windows is '\'
pathSeparator是多个路径之间的分隔符,linux is ':' and windows is ';'
至于后面的Char表示的是字符型,没有Char的是字符串型

如果没写构造函数那么会默认生成一个无参构造函数
如果写了的话那么就会存在已经写了的构造函数,无参构造函数就会不存在