虚拟机运行的时候,运行时常量池会保存大量的符号引用，这些符号引用可以看成是每个方法的间接引用。如果代表栈帧A的方法想调用代表栈帧B的方法，那么这个虚拟机的方法调用指令就会以B方法的符号引用作为参数，但是因为符号引用并不是直接指向代表B方法的内存位置，所以在调用之前还必须要将符号引用转换为直接引用，然后通过直接引用才可以访问到真正的方法。

如果符号引用是在类加载阶段或者第一次使用的时候转化为直接应用，那么这种转换成为静态解析，如果是在运行期间转换为直接引用，那么这种转换就成为动态连接

java垃圾回收机制
	什么样的对象可以被回收？
	最简单的是通过引用计数方式，但引用计数方式无法解决循环引用的问题
	所以后来通过GC Root，通过一些root对象一直遍历下去，能够遍历的就认为能够存活，无法遍历到的就认为可以回收
	并不是通过收集不可用的对象来清除，而是通过收集可用的对象然后清除其他
GCroot哪些是根对象呢？
	1、栈中引用的对象
	2、static静态变量
		静态方法和变量不产生实例，直接由类引用。Java的类由java.lang.ClassLoader类加载器加载，
		类的数据都不在逻辑堆，
		而是存在永生代，也就是Method Area方法区，现在叫Metaspace。类本身一旦被GC清除，他的所有静态变量
		也就跟着被释放了。
	3、main线程
		main方法就是一个thread线程。java里线程也都是继承自基类，所以自身也是一个大实例。
	4、JNI
		JNI是支持其他编程语言的本机码和Java字节码互相调用的程序。除了Java进程内部的调用，
		JVM还需要知道一个实例是否被外部本机代码所调用，JNI引用就列举了当前的外部调用。


java垃圾回收算法


1、标记清除
	也就是每次GC，会先扫描内存区标记存活对象，而后释放未被标记的对象空间。这种算法在工作时需要停止工作线程，再进行标记清除，同时会产生内存碎片，而且jvm需要维护一个内存空间表，用于分配内存空间。
2、标记整理
	标记阶段与标记清除算法一样。但后续并不是直接对可回收的对象进行清理，而是让所有存活对象都想一端移动，然后清理。优点是不会造成内存碎片。
3、复制算法
	将内存区域分为两部分，回收的时候将存活的对象复制到另一块内存中(排列紧密，无内存碎片)，然后转换逻辑角色
	再次回收的时候同时也对上一次存活的对象再次进行GCRoot，然后又复制到另一块内存区域，如此循环
4、分代算法
	内存区域分为两个区域:年轻代和老年代
	年轻代有分为三个部分:Eden   from    to
		新创建的对象放在Eden去
		使用回收算法进行回收(copying算法)，将Eden中存活的内容复制到from区
		第二次回收的时候将Eden区和from区的内容复制到to区，再清除Eden区和from区的内容
		然后进行from区和to区进行逻辑上的转换(from区变为to区，to区变为from区)
		再次回收的时候Eden区总是存在的，而from区也总是有对象的，回收的时候Eden区和from区总是需要进行
		GCRoot的，将无法引用到的对象剔除掉(没被引用到旧不复制)

5、CMS算法


引用计数法和可达性分析
引用计数法是为对象分配一个变量,每次当有其他变量引用该对象时就加一,如果为0则该对象需要被回收,会造成循环引用,
比如A引用B,B也引用A,这两个对象相互引用,而且该计数也都是1,那么这两个对象都不会回收
可达性分析是通过一系列的GCRoot,从这些对象一直向下搜索,他并不是搜索需要被回收的对象,而是搜索还能存活的对象,然后将这些对象放入sp1区,使用copy算法




java对象存储

对象头
成员变量
对其填充


shutDown()
    当线程池调用该方法时,线程池的状态则立刻变成SHUTDOWN状态。
    此时，则不能再往线程池中添加任何任务，否则将会抛出RejectedExecutionException异常。
    但是，此时线程池不会立刻退出，直到添加到线程池中的任务都已经处理完成，才会退出。
shutdownNow()
     根据JDK文档描述，大致意思是：执行该方法，线程池的状态立刻变成STOP状态，
     并试图停止所有正在执行的线程，不再处理还在池队列中等待的任务，当然，它会返回那些未执行的任务。
     它试图终止线程的方法是通过调用Thread.interrupt()方法来实现的，但是大家知道，这种方法的作用有限，
     如果线程中没有sleep 、wait、Condition、定时锁等应用, interrupt()方法是无法中断当前的线程的。
     所以，ShutdownNow()并不代表线程池就一定立即就能退出，它可能必须要等待所有正在执行的任务都执行完成了才能退出。
线程池的keepAliveTime
    如果设置了allowCoreThreadTimeOut为true
    那么核心线程存活时间为keepAliveTime
    如果没设置allowCoreThreadTimeOut
    那么只是非核心线程的存活时间为keepAliveTime

    getTask方法中,flag=允许核心线程超时|是否是核心线程


String变量赋值为null,那么常量池中的数据会清除吗?还是说gc只回收这个string变量

TreeMap
	Comparator
	Comparable
LinkedHashMap
	顺序访问
	在每个节点加入两个指针
	双向链表
HashMap
	ContainsKey
		if (e.hash == hash &&
                        ((k = e.key) == key || (key != null && key.equals(k))))
                        return e;
	先比较哈希码 在比较引用和equals方法
	ContainsValue
		if ((v = e.value) == value ||
                        (value != null && value.equals(v)))
                        return true;
	先比较引用，再比较equals方法
	capacity table数组的长度
	size  table数组实际存储的元素数量
	threshold 当size>threshold的时候进行resize扩容 threshold=capacity*loadFactory
	loadFactory装载因子 用来衡量table数组满的程度，size/capacity为实时转载因子，默认为0.75
	DEFAULT_INITIAL_CAPACITY	初始化table数组长度16
	MAXIMUM_CAPACITY	table数组的最大长度2^30
	DEFAULT_LOAD_FACTOR		默认装载因子0.75
	TREEIFY_THRESHOLD	默认的树化的阈值8
	UNTREEIFY_THRESHOLD		resize后树变为链表的阈值
		if (hc <= UNTREEIFY_THRESHOLD)
                    tab[index + bit] = hiHead.untreeify(map);
                else {
                    tab[index + bit] = hiHead;
                    if (loHead != null)
                        hiHead.treeify(tab);
                }
	MIN_TREEIFY_CAPACITY	树化时的最小capacity容量，如果一个桶中的bin大于TREEIFY_THRESHOLD默认树化阈值8的时候，如果table数组的capacity小于MIN_TREEIFY_CAPACITY
							则会进行扩容，当capacity>MIN_TREEIFY_CAPACITY的时候才进行树化




java分析工具
jinfo -flag MaxHeapSize pid

jinfo -flags pid

jstat -gc 13744

java的getProperties和getEnv
前者是获取Java的系统变量
后者是获取操作系统的变量,比如path变量


java的编码格式

编译时指定编码格式
javac -encoding utf8 test.java
运行时指定编码格式(同时这个编码格式也是在程序中使用System.getProperty("file.encoding")获取的值
java -Dfile.encoding=utf-8 test
以上两种的默认值都是操作系统的默认值

同一个类中的static方法可以访问当前类的私有成员变量(new了该对象之后可以直接访问该对象的私有变量)

ArrayList
new一个空的时候时一个默认的静态数组,所有共享
第一次add的时候容量变为10(默认容量)

Runtime.getRuntime().exec()
执行mv /home/* /home1/  发现无效
执行mv /home/fcy1.zip /home1/ 发现执行成功
