世界上不存在完全可靠的通信协议
两大关键功能
可靠性：保证数据确实到达目的地。如果未到达，能够发现并重传。
数据流控：管理数据的发送速率，以使接收设备不致于过载

大端和小端
高地址和低地址
0x12345678
4个字节

地址  01  02  03  04
大端  12  34  56  78
小端  78  56  34  12
网络发送时先取01地址的12发送
如果平台时小端存储，则发送前会将小端转换为大端，然后取高位的12发送

另外，Java和所有的网络通讯协议都是使用Big-Endian的编码。
网络协议规定接收到得第一个字节是高字节，
存放到低地址，所以发送时会首先去低地址取数据的高字节。
小端模式的多字节数据在存放时，低地址存放的是低字节，
而被发送方网络协议函数发送时会首先去低地址取数据（想要取高字节，真正取得是低字节），
接收方网络协议函数接收时会将接收到的第一个字节存放到低地址（想要接收高字节，真正接收的是低字节），
所以最后双方都正确的收发了数据。而相同平台进行通信时，如果双方都进行转换最后虽然能够正确收发数据，
但是所做的转换是没有意义的，造成资源的浪费。而不同平台进行通信时必须进行转换，不转换会造成错误的收发数据，
字节序转换函数会根据当前平台的存储模式做出相应正确的转换，如果当前平台是大端，则直接返回不进行转换，
如果当前平台是小端，会将接收到得网络字节序进行转换。

在TCP的三次握手中，后采用随机产生的初始化序列号进行请求，这样做主要是出于网络安全的因素着想。

SSL和TLS是位于传输层协议和应用层协议之间的,应用层的数据不再交给传输层,而是直接交给SSL协议或TLS协议,然后在由SSL或TLS交个传输层的协议,这两个协议是用来加密的,


如果不是随机产生初始序列号，黑客将会以很容易的方式获取到你与其他主机之间通信的初始化序列号，并且伪造序列号进行攻击，这已经成为一种很常见的网络攻击手段。

0				7				15				23				31
	Source Port						Destination Port
						 Sequence Number
						 Acknowledgment Number
Data Offset(4)   Reserved(6)   URG ACK PSH RST SYN FIN 		Window
	Checksum						UrgentPointer
	Options							Padding
						Data

规则1、累计确认。接收端对收到的载荷包（数据字段有值的TCP包），回应一个确认包，确认号是所收到包的TCP数据字段最后一个字节＋1。
规则2、捎带确认。载荷包必须捎带确认字段。这样可以减少网络流量。
规则3、虚字节。有些数据包（ACK）不携带任何数据，所以不消耗序列号，也就是说仍旧保持不变。
						
Source Port   源端口
Destination Port  目的端口
Sequence Number用来表明一共发送了多少数据 
Acknowledge Number用来表明一共接收到了多少数据 					
SYN表示建立连接，

FIN表示关闭连接，

ACK表示响应，

PSH表示有 DATA数据传输，

RST表示连接重置。

ACK是可能与SYN，FIN等同时使用的，比如SYN和ACK可能同时为1，它表示的就是建立连接之后的响应，

如果只是单个的一个SYN，它表示的只是建立连接。

TCP的几次握手就是通过这样的ACK表现出来的。

 但SYN与FIN是不会同时为1的，因为前者表示的是建立连接，而后者表示的是断开连接。

RST一般是在FIN之后才会出现为1的情况，表示的是连接重置。

 一般地，当出现FIN包或RST包时，我们便认为客户端与服务器端断开了连接；而当出现SYN和SYN＋ACK包时，我们认为客户端与服务器建立了一个连接。

PSH为1的情况，一般只出现在 DATA内容不为0的包中，也就是说PSH为1表示的是有真正的TCP数据包内容被传递。



滑动窗口本质上是描述接受方（本地）的TCP数据报缓冲区大小的数据，发送方根据这个数据来计算自己最多能发送多长的数据。如果发送方收到接受方的窗口大小为0的TCP数据报，那么发送方将停止发送数据，等到接受方发送窗口大小不为0的数据报的到来
服务器必须将确认信息发回客户端以表明数据接收。服务器必须处理数据，将它传递给目标应用程序处理
你在发送数据的时候，是发送给服务器的，在基本的滑动窗口机制中，服务器数据于接收时确认，但并不一定立即从缓存中传输出去。也就意味着当接收数据速度快于接收TCP处理速度时，缓存有可能被填满。当这一情况发生时，接收设备需要调小窗口已防止缓存过载。如果相反，它会调大窗口。在这里决定窗口大小的不是接收窗口，而是服务器缓存的空闲空间。
除了发回确认信息给客户端以外，服务器会想要告知客户端更改窗口大小，以表示缓存已经被部分 写入了


三次握手

	client              server
1		SYN=1
2				SYN=1,ACK=1
3		ACK=1
第一次握手  客户端发送SYN=1,客户端进入SYN_SEND状态
第二次握手  服务端返回SYN=1,ACK=1,服务端进入SYN_RECV状态
第三次握手  客户端发送ACK=1,此后服务端和客户端都进入ESTABLISHED状态



四次挥手
		client				server 
客户端发送关闭请求
客户端:我没有要发送的数据了,我要关闭写通道了					
服务端:所以我没有要接受的数据了,我关闭读通道了
服务端:我也没有要发送的数据了,我要关闭写通道了
客户端:所以我没有要接受的数据了,我关闭读通道了
1服务端读通道关闭
2


注意：close时，如果TCP发送队列中还有数据，那么将会发送RST包而不是FIN包。

close和shudown的区别



已经发送并确认
已经发送未确认
未发送但允许发送
未发送暂不允许发送

已经接受并确认
未接受准备接受
未接收并未准备接收



tcp接收是有序的
序到达的ip报文最终组成了有序的数据，有序组装而不遗漏就是靠的tcp期待的下一个字节序，
不然，发送方怎么知道←_←发送那个
三次握手状态变化
SYN_SEND				LISTEN
						SYN_RECIVED
ESTABLISHED
						ESTABLISHED
四次挥手状态变化
ESTABLISHED				ESTABLISHED
FIN_WAIT1				
						CLOSE_WAIT
FIN_WAIT2
						LAST_ACK
TIMEWAIT
						CLOSED
	CLOSED

版本	首部长度	服务类型				总长度
			标识					标志			片偏移
生存时间	协议							首部检验和
						原地址
						目的地址
		可选字段						填充
						数据
版本 4
首部长度 4
服务	8  不怎么使用
总长度 16  指收不及数据之和的长度 最大长度65535字节
标识 16    IP软件在存储器中维持一个计数器,每产生一个数据包计数器就加一,并将此值赋给标识字段,但这个字段并不是序号,当数据包由于长度超过网络的MTU而必须分片时,这个标示字段就被赋值到所有的数据的标示字段中。相同的标示字段的值分片后的各个数据包片最后能正确第重装称为原来的数据包
标志 3 目前只有两位有意义   最后一个为MF,为1时表示后面还有分片的数据包，为0时表示这是若干数据包片中的最后一个
中间以为记为DF，当DF=0时才允许分片，为1时不允许分片
片偏移  13较长的分组在分片后，某片咋原分组中的相对位置每个分片的长度一点是8字节的整数倍
生存时间  8  防止无法交付的数据包无限地在因特网中兜圈子，浪费网络资源
每经过一个路由器就把TTL减去数据包在路由器消耗掉的一段时间，当TTL为0时，就丢弃这个数据包
协议  8  指出此数据包接待的数据是使用何种协议，以便目的机器知道将数据部分上交给那个处理过程
首部检验和  16  


IP数据包的总长度过大超过链路的最大MTU时，数据包就会分成很多片
数据传输是不可靠的
所以这些分片的数据道远到大对端的链路和时间都是不同的

IP协议是不可靠的。当IP数据包丢失的时候，要更高一层 的协议认识到数据包的丢失并要求重新发送



IP协议是尽力而为的
TCP实现了有连接  可靠传输	报文按序到达

使用3次握手是因为3次握手已经准备好了传输可靠性以及数据顺序性所必要的信息，该握手的第3次实际上并不是需要单独传输的，完全可以和数据一起传输。


我们把网络定义为互相连接在一起的设备，网络的本质作用还是“端到端”的通信，然而希望互相通信的设备并不一定要“直接”连接在一起，因此必然需要一些中间的设备负责转发数据，因此就把连接这些中间设备的线缆上跑的协议定义为链路层协议，实际上所谓链路其实就是始发与一个设备，通过一根线，终止于另一个设备。我们把一条链路称为“一跳”。因此一个端到端的网络包含了“很多跳”。

总之，TCP要点有四，一曰有连接，二曰可靠传输，三曰数据按照到达，四曰端到端流量控制。注意，TCP被设计时只保证这四点，此时它虽然也有些问题，然而很简单，然而更大的问题很快呈现出来，使之不得不考虑和IP网络相关的东西，比如公平性，效率，因此增加了拥塞控制，这样TCP就成了现在这个样子
首先我们认识一下为何IP协议是沙漏的细腰部分。它的下层是繁多的链路层协议，这些链路提供了相互截然不同且相差很远的语义，为了互联这些异构的网络，我们需要一个网络层协议起码要提供一些适配的功能，另外它必然不能提供太多的“保证性服务”，因为上层的保证性依赖下层的约束性更强的保证性，你永远无法在一个100M吞吐量的链路之上实现的IP协议保证1000M的吞吐量…

IP协议设计为分组转发协议，每一跳都要经过一个中间节点，路由的设计是TCP/IP网络的另一大创举，这样，IP协议就无需方向性，路由信息和协议本身不再强关联，它们仅仅通过IP地址来关联，因此，IP协议更加简单。路由器作为中间节点也不能太复杂，这涉及到成本问题，因此路由器只负责选路以及转发数据包。
因此传输控制协议必然需要在端点实现。在我们详谈TCP协议之前，首先要看一下它不能做什么，由于IP协议不提供保证，TCP也不能提供依赖于IP下层链路的这种保证，比如带宽，比如时延，这些都是链路层决定的，既然IP协议无法修补，TCP也不能，然而它却能修正始于IP层的一些“不可保证性质”，这些性质包括IP层的不可靠，IP层的不按顺序，IP层的无方向/无连接。



tcp协议
三次握手
四次挥手
窗口机制
状态转变

三次握手
在每一次交互的报文中都有sequence和acknowledgement两个字段，同样还有报文中装载的数据和描述数据长度的len
sequence表示我方已经发送了多少数据给对方-1，同时也代表这次发送的数据的第一个数据的序列
acknowledge代表我方接受了对方多少数据-1，同时也代表我方期望收到对方的下一个数据包的第一个字节的序列号


sequence 代表我方已经发送了的数据
ack 代表我方已经接受的数据

	sequence   acknowledge   len
1   1          1             100   发送100个字节
2	1		   101           300	接受了100个字节并发送300个字节
1	101			301		     200   这次发送的数据的第一个字节顺序为101，我方期望对方下一个数据包的序列为301
	
	
	
状态转变
closed   closed
syn-send  syn-receive
established established
发送syn=1变为syn-send状态
接受syn=1并发送syn=1，ack=1变为syn-received状态
接受syn=1，ack=1并发送ack=1变为established状态
接受ack=1变为established状态

序列号变化  00  01  11

发送fin=1变为fin-wait状态
FIN
FIN ACK
FIN
FIN ACK

fin_wait1
fin_wait2
time_wait

closed_wait
last_ack
closed

为什么是四次挥手？
因为服务器收到对方的FIN报文后，只是知道了对方确认关闭了，但是自己不一定就在此刻关闭，
因为还有可能服务器端还有数据需要传输
全双工传输，每端既有发送缓冲区和接受缓冲区
发送FIN报文只是代表发送端的发送缓冲区不可以再次发送数据了，但是接受缓冲区还是可以继续接受数据的
服务器自己的数据也传输完毕了后，服务器发送FIN报文告诉客户端我方已经发送完毕，
然后客户端接受服务端的FIN报文后知道了已经没有数据需要发送了
客户端发送一个ACK给服务器
然后服务器接受到ACK后关闭连接
客户端需要等待2MSL后才关闭连接
SYN 和纯 ACK 发送时不入队列


PUSH标志
发送端发送的数据带有PUSH标志  标识该数据包应该立刻被发送而不用等待其他数据一起发送
接收端接受的数据带有PUSH标志  标识该数据包应该立刻提交给应用层去处理
当前没有API来设置哪些数据应该带有PUSH标志，完全有TCP的处理程序决定


MSS最大报文长度 是tcp的可选字段，标识该tcp报文中的数据的最大长度，一般在三次握手的时候发送的

127777437





滑动窗口
发送窗口
	已经发送并收到ACK的		已经发送但没有收到ACK的		未发送并且允许发送的		未发送但不允许发送的
	
接受窗口
	已经接受并发送了ACK		已经接受但没有发送ACK	

流量控制   拥塞控制
	

网络上数据的传输是没有连接的
连接是通过人为的手段来维持的
tcp通过保持一组状态来维持这一连接，使之看起来像有连接一样
tcp有三个阶段
连接的建立	数据的传输	连接的关闭
连接的建立
	建立连接需要三次握手
	由此引发了一个问题：为什么是三次握手？其他次数行不行？三次握手都干了啥？
数据的传输
	每个数据包都有以下基本信息
		SRCPort，DSTPort,Sequence,Acknowledge,head_len,six_reserved,URG、PUSH、ACK、SYN、FIN、RESET，
		Win,CheckSum,UrgentPoint
		源端口，目的端口，序列号，确认号，头部长度，六位保留，六位标志，窗口大小，检验和，紧急指针
	数据的传输基本原则
		0、数据的传输的有序性通过Sequence和Acknowledge来保证，seq代表本次数据包的第一个字节的序号，ack代表
		期望收到对方的下一个数据包的第一个序号
		1、发送端发送数据后必须收到接受端的ACK包
		2、接收端收到数据后并不是立刻发送ACK包
		3、接收端并不是为每一个数据包都发送一个ACK包，他只为最后收到的一个数据包发送ACK包
		3、如果数据包丢失就需要重传。怎样重传？
	由于网络是不确定的，所以发送的数据包可能丢失，也可能阻塞，也可能造成发送端发送数据过快而使得接收端接受
不过来
	数据包丢失需要重传机制
	同步发送端和接收端的速率问题需要滑动窗口
	重传机制
		发送端发送了一个数据包后会启动一个定时器，如果不能收到确认则会重发此报文
		对于发送端来说，只有一种情况，我发送了一个数据包，但是没有收到ACK包
		有两种可能：发送的数据丢失、接收端返回的ACK丢失
		发送的数据丢失：接收端通过发送ACK告诉发送端我期望的下一个数据包的第一个字节的序号
		接受的ACK可能丢失:发送端没有收到ACK，重发此报文，接收端发现该报文已经存在了
	滑动窗口
		通过接收端返回的ACK包来调整发送端发送数据的速率
	tcp通过一个定时器来接受接收端的ACK报文，这个定时器的时间是多少又是一个问题
	如果网络的延迟非常大，那么tcp对于丢失的报文只有重传数据，但是重传又会导致网络的延迟更加严重，
	由此导致一种恶性循环，所以tcp不能忽略网络上发生的事情而一味的重传数据，tcp不是一个自私的协议，
	当拥塞发生的时候
	要做自我牺牲，由此有几个算法可以解决
	慢启动		拥塞避免		拥塞发生		快速恢复
	
	tcp协议的误区				
	操作系统上端口号1024以下是系统保留的，从1024-65535是用户使用的。由于每个TCP连接都要占一个端口号，
所以我们最多可以有60000多个并发连接。我想有这种错误思路朋友不在少数吧？（其中我过去就一直这么认为
	如何标识一个tcp连接：一个tcp连接有一个四元组组成(src_ip,src_port,dst_ip,dst_port),其中目的地址ip和目的
地址端口在服务器上是不变的，但是原地址ip和原地址端口是可变化的，所以一个端口可以有许多tcp连接


tcp对于收到的乱序报文并不丢弃，而是缓存起来（减少发送端重传），然后立即发送希望接收的报文确认

第一次发送SYN后没收到SYN+ACK，隔多久再次发送SYN？
最大报文长度？
同时发送SYN和同时发送FIN会怎样？FIN_WAIT1--->CLOSING---->TIME_WAIT
TIME_WAIT的2MSL等待时间？
连接的关闭，正常关闭和异常关闭？
tcp的半连接怎么办？
RTT，一个连接的往返时间测量，它是动态的
RTO，每次发送一个报文的时候开启一个定时器，若在给定时间内没收到ACK则重传，定时器的时间设置为多少合适？
重传机制，重传多少次？每隔多久重传一次？


TCP的几大计时器
	1、重传计时器   
		发送端发送一个报文的时候会启动一个计时器，如果指定时间内没有收到接收端的ack报文则会重新发送报文
		如果重传之后还没有收到接收端的ack报文则
		　　定时器时间为动态计算的,常见公式新RTT=旧RTT的90%+当前RTT*10%
	2、坚持计时器
		发生在滑动窗口为0的时候，如果发送端收到接收端的ack报文的滑动窗口大小为0时，发送端会停止发送报文，
		然后等待客户端的滑动窗口不为0的ack报文，等待多久呢？如果接收端的该报文丢失了的话则会进入死锁状态，
		发送端等待窗口不为0的ack报文，接收端等待发送端发送报文
		当发送端收到窗口为0的ack报文的时候启动一个定时器，如果指定时间内还没有收到窗口不为0的ack报文，则发送一个
		探测报文，告诉接收端你发的ack报文丢失了，如果接收端的窗口大小还是为0，则时间翻倍，然后复位继续等待
	3、保活计时器
		tcp双方没有数据发送的时候能持续的最大时间
		或者通过发送指定探次数探测报文
	4、等待计时器
		主动关闭的一方进入TIME_WAIT状态，防止一些超时报文
	5、主动连接的一方发送SYN后如果没有收到SYN+ACK，等待多久？
	6、主动关闭的一方发送FIN报文并收到对方的ACK报文后进入FIN_WAIT2状态，在该状态下若迟迟没有收到对方的FIN报文
		等待多久
	7、











水平触发和边缘触发
				在nio模型中，一个线程可以监听多个IO事件的到来，当IO事件来临时，用户程序会调用read方法读取socket缓冲区中的数据，此时如果一次read没读完
				再次调用select的时候是否会返回上次没读完的io事件的socket，
				水平触发模式下只要缓冲区中有数据则会响应一次io事件
				而在边缘触发模式下它认为我已经响应了这次io事件，所以不再响应，只有当网络中下一次新的io事件来临时才响应，
				
				水平出发只要有数据可读就触发一次
				而边缘触发则是不管数据有没有读完，只响应io事件
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				网卡中的缓冲区既不属于内核空间，也不属于用户空间。它属于硬件缓冲，允许网卡与操作系统之间有个缓冲；
内核缓冲区在内核空间，在内存中，用于内核程序，做为读自或写往硬件的数据缓冲区；
用户缓冲区在用户空间，在内存中，用于用户程序，做为读自或写往硬件的数据缓冲区；
为了加快数据的交互，可以将内核缓冲区映射到用户空间，这样，内核程序和用户程序就可以同时访问这一区间了。


网卡芯片收到网络数据会以中断的方式通知CPU，我有数据了，存在我的硬件缓冲里了，来读我啊。
CPU收到这个中断信号后，会调用相应的驱动接口函数从网卡的硬件缓冲里把数据读到内核缓冲区，正常情况下会向上传递给TCP/IP模块一层一层的处理。

网卡的中断信号由内核感知，并从网卡端口读取数据，因此，网卡上的数据交换端口（也是CPU端口）属于内核空间（虽然，也可以映射到用户空间）；
  网卡上的数据缓冲区，内核不能直接访问，是网卡芯片硬件自己控制的（当然，需要CPU对网卡芯片初始化），所以不属于内核空间。
  
  
  这个DMA是计算机系统内总线上的，它和CPU都挂在总线上，它可以和CPU竞争使用总线，即在CPU不使用总线时(CPU只在取指令和存取数据时才使用总线，计算过程是在CPU内部处理的是不使用总线的，所以虽然CPU一直再用总线，但它只是以一定频率使用，中间的总线空闲比率是很大的)使用总线实现内存到内存，外设到内存，内存到到外设的数据传输，这一过程不需要CPU控制，但需要CPU初始化一下DMA控制器，目的是告诉DMA控制器的源地址和目的地址，传输的数据个数，以及还可能设置DMA中断(传输多少数据后产生中断信号)。网卡是计算机系统内的一个“被动”的设备，是没有权限控制主板上的DMA控制器的。他只能给个信号，告诉CPU我有数据了，然后CPU确定有多少数据，初始化一下DMA控制器告诉DMA控制器从网卡接口中读出多少数据到内核空间的内存中。
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				协议
网卡
端口
两层命名空间




127.0.0.1
192.168.43.176
0.0.0.0
首先，0.0.0.0是不能被ping通的。在服务器中，0.0.0.0并不是一个真实的的IP地址，它表示本机中所有的IPV4地址。监听0.0.0.0的端口，就是监听本机中所有IP的端口。




Foregin Address：对外开放，一般都为0.0.0.0：* 

重点说明 0.0.0.0 是对外开放，通过服务域名、ip可以访问的端口

               127.0.0.1 只能对本机 localhost访问，也是保护此端口安全性
			   
			   
			   
			   
1、0.0.0.0代表本机上可用的任意地址。 比如0.0.0.0:135 表示本机上所有地址的135端口，这样多ip计算机就不用重复显示了。
2、TCP 0.0.0.0:80表示在所有的可用接口上监听TCP80端口 
3、0.0.0.0为默认路由，即要到达不再路由表里面的网段的包都走0.0.0.0这条规则








0.0.0.0/8可以表示本网络中的所有主机，0.0.0.0/32可以用作本机的源地址，0.0.0.0/8也可表示本网络上的某个特定主机,综合起来可以说0.0.0.0表示整个网络。它的作用是帮助路由器发送路由表中无法查询的包。如果设置了全零网络的路由，路由表中无法查询的包都将送到全零网络的路由中去。
 
 
在路由器配置中可用0.0.0.0/0表示默认路由，作用是帮助路由器发送路由表中无法查询的包。如果设置了全零网络的路由，路由表中无法查询的包都将送到全零网络的路由中去。严格说来，0.0.0.0已经不是一个真正意义上的IP地址了。它表示的是这样一个集合：所有未知的主机和目的网络。这里的“未知”是指在本机的路由表里没有特定条目指明如何到达












现在有两台pc在同一个局域网内，分别为pc1与pc2，pc1上有一个网卡，IP地址为192.168.10.128

pc1中sever监听127.0.0.1，则pc1中的client可以连上127.0.0.1，192.168.10.128连不上；而pc2中client都连不上。
pc1中sever监听192.168.10.128，则pc1中的client可以连上192.168.10.128，127.0.0.1连不上；而pc2中client能连上192.168.10.128。
pc1中sever监听0.0.0.0，则pc1中的client可以连上127.0.0.1和192.168.10.128，pc2中的client能连上192.168.10.128。











http协议
Transfer-encoding  传输编码，目前只有一种取值，chunked分块编码
出现原因:每个普通的Http报文都有一个Content-length代表body部分的长度，当服务器要传输一个大文件到客户端的时候,这个content-length就有点麻烦了，只能开一个足够大的buffer，既消耗内存空间有浪费客户端等待时间
所以此时就出现了分块编码，
sock.write('HTTP/1.1 200 OK\r\n');
        sock.write('Transfer-Encoding: chunked\r\n');
        sock.write('\r\n');

        sock.write('b\r\n');
        sock.write('01234567890\r\n');

        sock.write('5\r\n');
        sock.write('12345\r\n');

        sock.write('0\r\n');
        sock.write('\r\n');
如上图，每个分块都有两个部分，分块的长度和内容，每个分块以换行符隔开，最后一个分块的长度值必须为0，代表分块结束
分块编码的好处:
	HTTP分块传输编码允许服务器为动态生成的内容维持HTTP持久链接。通常，持久链接需要服务器在开始发送消息体前发送Content-Length消息头字段，但是对于动态生成的内容来说，在内容创建完之前是不可知的。
	[1]分块传输编码允许服务器在最后发送消息头字段。对于那些头字段值在内容被生成之前无法知道的情形非常重要，例如消息的内容要使用散列进行签名，散列的结果通过HTTP消息头字段进行传输。没有分块传输编码时，服务器必须缓冲内容直到完成后计算头字段的值并在发送内容前发送这些头字段的值。HTTP服务器有时使用压缩 （gzip或deflate）以缩短传输花费的时间。
	分块传输编码可以用来分隔压缩对象的多个部分。在这种情况下，块不是分别压缩的，而是整个负载进行压缩，压缩的输出使用本文描述的方案进行分块传输。在压缩的情形中，分块编码有利于一边进行压缩一边发送数据，而不是先完成压缩过程以得知压缩后数据的大小

Content-encoding代表的是内容编码，指使用压缩算法压缩内容







1、阻塞io
2、非阻塞io
3、io复用
4、信号驱动io(不了解)
5、异步io

从磁盘读取文件经过网卡发送出去
	磁盘-->内核空间-->应用程序空间-->协议栈-->


IO多路复用是指内核一旦发现进程指定的一个或者多个IO条件准备读取，它就通知该进
程

select	
（1）使用copy_from_user从用户空间拷贝fd_set到内核空间
（2）注册回调函数__pollwait
（3）遍历所有fd调用其对应的poll方法（对于socket，这个poll方法是sock_poll，
sock_poll根据情况会调用到tcp_poll,udp_poll或者datagram_poll）
（4）以tcp_poll为例，其核心实现就是__pollwait，也就是上面注册的回调函数。
（5）__pollwait的主要工作就是把current（当前进程）挂到设备的等待队列中，不同
的设备有不同的等待队列，对于tcp_poll来说，其等待队列是sk->sk_sleep（注意把
进程挂到等待队列中并不代表进程已经睡眠了）。在设备收到一条消息（网络设备）或
填写完文件数据（磁盘设备）后，会唤醒设备等待队列上睡眠的进程，这时current便
被唤醒了。
（6）poll方法返回时会返回一个描述读写操作是否就绪的mask掩码，根据这个mask掩码
给fd_set赋值。
（7）如果遍历完所有的fd，还没有返回一个可读写的mask掩码，则会调用
schedule_timeout是调用select的进程（也就是current）进入睡眠。当设备驱动发生
自身资源可读写后，会唤醒其等待队列上睡眠的进程。如果超过一定的超时时间
（schedule_timeout指定），还是没人唤醒，则调用select的进程会重新被唤醒
获得CPU，进而重新遍历fd，判断有没有就绪的fd。
（8）把fd_set从内核空间拷贝到用户空间。
select睡眠和唤醒过程
　　select巧妙的利用等待队列机制让用户进程适当在没有资源可读/写时睡眠，有资源
	可读/写时唤醒。
select睡眠过程

	while(true){
		int flag=fd->driver->poll()
	}
　　select会循环遍历它所监测的fd_　set内的所有文件描述符对应的驱动程序的poll函
	数。 
　　驱动程序提供的poll函数首先会将调用select的用户进程插入到该设备驱动对应资
	源的等待队列(如读/写等待队列)，然后返回一个bitmask告诉select当前资源哪些可用。　 
　　当select循环遍历完所有fd_set内指定的文件描述符对应的poll函数后，如果没有
	一个资源可用(即没有一个文件可供操作)，则select让该进程睡眠，一直等到有资可
	用为止，进程被唤醒(或者timeout)继续往下执行。
select唤醒过程
　　唤醒该进程的过程通常是在所监测文件的设备驱动内实现的。 
　　驱动程序维护了针对自身资源读写的等待队列。当设备驱动发现自身资源变为
	可读写并且有进程睡眠在该资源的等待队列上时，就会唤醒这个资源等待队列上的
	进程。
select的缺点
　　1.每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大 
　　2.同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大 
　　3.select支持的文件描述符数量太小了，默认是1024


设备驱动程序
读取数据就是从将数据从内核拷贝到用户空间
数据在内核的缓存区中
当缓冲区中没有数据的时候
一个io通道就是一个文件描述符
设备驱动程序有一个等待队列,当设备有事件发生时会通知等待队列中的程序
selector是另一个进程
IO多路复用 一个线程监控多条io通道,但不是使用轮询,而是相应的设备驱动程序告知

注册文件句柄到内核的驱动程序中
将selector进程挂到驱动程序的等待队列中
当有事件发生的时候唤醒等待队列中的程序

select是当有事件发生的时候去轮询所有的io通道,然后将就绪的io通道加入到相应的集合中
epoll是当有事件发生的时候

select模式
	每次调用select方法的时候
	将所有的文件描述符从用户空间拷贝到内核空间
	遍历每个文件描述符的poll方法,该方法的功能:将当前进程挂到相应驱动程序的等待队列中
	该方法返回时会返回一个描述读写操作是否就绪的mask,根据这个掩码给fd_set赋值,描述通道的状态(读写等)
	如果遍历所有的文件描述符还没有返回一个可用的mask,则当前进程进入睡眠
	当设备驱动程序发生可读写事件的时候唤醒等待队列上的进程,如果超过一段时间(用户指定)还是没唤醒则该进程重新获取CPU重新遍历所有文件描述符重新判断
	最后是将可用的文件描述符从内核空间拷贝到用户空间
	缺点:用户空间和内核空间的频繁拷贝
		 每次调用select都要遍历所有的文件描述符
		 文件描述符太小1024
epoll模式
	epoll是基于回调机制的
	epoll除了会把当前进程挂入到相应的驱动程序的等待队列中,还会为每个fd指定一个回调函数
	当驱动程序唤醒该进程的时候就会调用这个回调函数
	这个回调函数会把当前文件描述符加入到一个就绪列表中
	
	然后epoll只是去遍历这个就绪列表
	而select需要遍历所有的fd集合






1同步阻塞
	应用程序调用系统提供的API,应用程序阻塞,内核调用对应的API等待数据到来,数据
	没到来则系统提供的
	API一直不返回,应用程序阻塞,数据到来,内核返回数据(从内核空间复制数据到应
	用程序空间),应用程序得到数据
2非阻塞
	应用程序调用系统提供的API,该数据有没有数据都立即返回,然后应用程序通过该
	函数返回的数据判断是否有数据，没有数据则一直调用该函数
3IO复用
	该模式把IO读取分为  IO订阅和IO读取
	

Direct I/O和Buffered I/O
Linux在进行I/O操作的时候会先把数据放到PageCache中然后通过“内存映射”的方式返回
给应用程序，这样做的好处是可以预读数据也能在多个进程读取相同数据的时候起到
Cache的作用。应用程序不能直接使用PageCache中的数据，通常是复制到一块“用户空间”
的内存中再使用。
Direct I/O是指数据不落在PageCache，直接从设备读取到数据后放到用户空间中
Buffered I/O是指数据竞购PageCache
同步I/O只能使用Buffered I/O;异步阻塞I/O可以Buffered I/O也可以使用Direct I/O;
异步非阻塞I/O只能使用Direct I/O



	
	
select
将fd_set从用户空间复制到内核空间
遍历所有文件描述符的poll函数
poll函数会返回是否有数据，
	有数据则置-1，
	没有数据则将当前进程挂载驱动程序的设备等待队列

epoll不需要遍历所有文件描述符
epoll只需要遍历活跃的文件描述符


NIO是IO多路复用的一种,有五种IO模式,同步阻塞,非阻塞,同步非阻塞,
aio是调用IO,将地址和回调函数地址注册进去,然后数据到来的时候讲数据写入用户指定的空间地址,然后调用用户注册的回调函数
NIO是select模式,该模式是阻塞在一个select调用上,该模式会将用户空间的文件描述符复制到内核
然后注册,然后select是否有io事件到来,如果有则将文件描述符复制到用户空间,然后用户对这所有的文件描述符轮训

epoll模式是将文件描述符复制到内核空间,然后为每个文件描述符注册一个回到函数,每当IO时间来临的时候他会将该描述符复制到一个特定的结构中,然后epoll只需要遍历这个结构中的文件描述符就行了,并不需要遍历所有的文件描述符
	
# Nagle算法
    算法来由:如果tcp每次只有一个字节的数据write到tcp的发送缓冲区
    那么tcp每次都会发送,造成一个字节的数据和40多个字节的首部数据
    
    在某些情况下不能忍受
    
    基于这种情况,产生了Nagle算法
    
    我们总希望tcp每次发送数据的时候能够发送足够大的数据
    避免网络中存在小数据块
    
    Nagle算法是在任意时刻,最多只能存在一个未被确认的小段
    小段是指小于MSS尺寸的数据块
    MSS是最大报文大小Max Segment Size
    
    if there is new data to send #有数据要发送
            # 发送窗口缓冲区和队列数据 >=mss，队列数据（available data）为原有的队列数据加上新到来的数据
            # 也就是说缓冲区数据超过mss大小，nagle算法尽可能发送足够大的数据包
            if the window size >= MSS and available data is >= MSS 
                send complete MSS segment now # 立即发送
            else
                if there is unconfirmed data still in the pipe # 前一次发送的包没有收到ack
                    # 将该包数据放入队列中，直到收到一个ack再发送缓冲区数据
                    enqueue data in the buffer until an acknowledge is received 
                else
                    send data immediately # 立即发送
                end if
            end if
        end if　
    
    Nagle算法只允许一个未被ACK的包存在于网络，它并不管包的大小，因此它事实上就是一个扩展的停-等协议，只不过它是基于包停-等的，而不是基于字节停-等的。Nagle算法完全由TCP协议的ACK机制决定，这会带来一些问题，比如如果对端ACK回复很快的话，Nagle事实上不会拼接太多的数据包，虽然避免了网络拥塞，网络总体的利用率依然很低
# tcpdump
    Linux抓包是通过注册一种虚拟的底层网络协议来完成对网络报文
    (准确的说是网络设备)消息的处理权。当网卡接收到一个网络报文之后，
    它会遍历系统中所有已经注册的网络协议，
    例如以太网协议、x25协议处理模块来尝试进行报文的解析处理，
    这一点和一些文件系统的挂载相似，
    就是让系统中所有的已经注册的文件系统来进行尝试挂载，
    如果哪一个认为自己可以处理，那么就完成挂载。
    
    当抓包模块把自己伪装成一个网络协议的时候，
    系统在收到报文的时候就会给这个伪协议一次机会，
    让它来对网卡收到的报文进行一次处理，此时该模块就会趁机对报文进行窥探，
    也就是把这个报文完完整整的复制一份，假装是自己接收到的报文，
    汇报给抓包模块。

    通过在底层注册一种网络协议
    然后操作系统会加载所有注册了的协议来处理从网络上收到的报文
    每种协议处理自己感兴趣的内容
    tcp -i eth0 -X host 120.79.158.25 and tcp port 3306
    监听120.79.158.25的3306端口的报文
# MTU和MSS
    MTU:最大传输单元
    以太网帧最大大小为1518字节
    以太网报文大小18
    IP报文最小20
    TCP头最小20
    TCP包的大小(MSS)是1518-18-20-20=1460
    MSS:最大报文大小