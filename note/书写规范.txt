WARNING: /base/bigData/hadoop/logs does not exist. Creating
使用防御性编程
参数检测时需要考虑最小和最大,多考虑边界检查
参数顺序控制:状态变量和不二变量放在最后面
不要把参数当作工作变量
把传入子程序的参数用作工作变量是非常危险的
通向的技术也被用于保持全局变量的值
如果你需要为全局变量计算一个新值
那应该在计算的最后把最终值赋给全局变量
而不要把中间值赋给他
public void run() {
        if (state != NEW ||
            !UNSAFE.compareAndSwapObject(this, runnerOffset,
                                         null, Thread.currentThread()))
            return;
        try {
            Callable<V> c = callable;//这里为什么需要使用一个局部变量,而不是直接使用callable这个成员变量
            //这样做有什么好处,或者还说是为了防止一些其他方面的影响,或者只是一种习惯,亦或者随意
            //上面这种写法有三条指令
                             //ALOAD 0
                             //GETFIELD java/util/concurrent/FutureTask.callable : Ljava/util/concurrent/Callable;
                             //ASTORE 1
            if (c != null && state == NEW) {
                V result;
                boolean ran;
                try {
                    result = c.call();
                    ran = true;
                } catch (Throwable ex) {
                    result = null;
                    ran = false;
                    setException(ex);
                }
                if (ran)
                    set(result);
            }
        } finally {
            // runner must be non-null until state is settled to
            // prevent concurrent calls to run()
            runner = null;
            // state must be re-read after nulling runner to prevent
            // leaked interrupts
            int s = state;
            if (s >= INTERRUPTING)
                handlePossibleCancellationInterrupt(s);
        }

code message success data
代码  信息  成功或者失败  数据