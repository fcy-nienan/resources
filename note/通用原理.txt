继承和组合？
代码点和代码单元？
缓存和缓冲？
数据是什么？
数据和状态？
离散和连续？
什么是面向对象编程？
事务放在那一层面？
怎样处理异常？
什么是锁？
编码和加密的区别？

  

一个对象持有其他对象的引用是正常的,
这样我们才能更好的定义该对象本身的一些行为,专注于该对象本身的特性


数据是什么?
	数据是一堆字节和其定义在其上的操作
这样的数据才有意义,要不然只有一堆字节的话,在每个人看来都可以有不同的意思
,只有其上的操作定义了其才有意义
	在代码中就是定义其变量,然后变为私有的类型,使得其他人不可直接访问该
	变量,而是通过我们自己定义的一些public的方法来访问,只要正确定义了其上
	的操作方法,那么也就定义了其数据的真正含义
	

	数据和状态

	
	PC程序计数器是一个抽象的概念
CS:IP寄存器是其具体的实现

硬件错误是常态，因此需要冗余

	在计算机中的数据的保存和运算都是以二进制的形式进行的,但不是直接的原码,而是原码的补码,也就是说在计算机中,数据的运算都是以数据的补码进行的
	
	
	将一个字符串映射到一个数组中时,你只能得到其指定位置是否存在,但是得不到其映射时的输入顺序



寻找两个字符串中的最小连续子串
	
	
	
		
什么是锁

在单进程的系统中，当存在多个线程可以同时改变某个变量（可变共享变量）时，就需要对变量或代码块做同步，使其在修改这种变量时能够线性执行消除并发修改变量。

而同步的本质是通过锁来实现的。为了实现多个线程在一个时刻同一个代码块只能有一个线程可执行，那么需要在某个地方做个标记，这个标记必须每个线程都能看到，当标记不存在时可以设置该标记，其余后续线程发现已经有标记了则等待拥有标记的线程结束同步代码块取消标记后再去尝试设置标记。这个标记可以理解为锁。

不同地方实现锁的方式也不一样，只要能满足所有线程都能看得到标记即可。如java中synchronize是在对象头设置标记，Lock接口的实现类基本上都只是某一个volitile修饰的int型变量其保证灭个线程都能拥有对该int的可见性和原子修改，linux内核中也是利用互斥量或信号量等内存数据做标记。
除了利用内存数据做锁其实任何互斥的都能做锁（只考虑互斥情况），如流水表中流水号与时间结合做幂等校验可以看作是一个不会释放的锁，或者使用某个文件是否存在作为锁等。只需要满足在对标记进行修改能保证原子性和内存可见性即可。


leader和follow模型
假设有n个线程，那么其中一个线程为leader，该线程监听网络，发现连接后负责处理该连接，当该线程处理一个连接时，该线程成为follower，其他的空闲follower通过竞争成为新的leader，这样的好处是避免了线程切换带来的开销。



Reactor模型

分层模型
底层为上层提供服务

解释器模型
sql语言
Master/Slave模型

MVC模型

客户端/服务器模型

管道过滤器模型

代理模型

点对点模型
在这种模式中，单个组件被称为对等点。对等点可以作为客户端，从其他对等点请求服务，作为服务器，为其他对等点提供服务。对等点可以充当客户端或服务器或两者的角色，并且可以随时间动态地更改其角色。

事件总线模型
事件源，事件通道，事件总线，事件监听器

黑板模式

生产者消费者模型

