# 基本原理

自顶向上和自底向上
最左推导和最右推导

+ 词法分析,将输入的字符串生成一个个词法单元token然后传递给语法分析器
+ 语法分析,根据输入的词法单元构建抽象语法树AST
+ 语义分析,对生成的AST语法树进行分析
+ 中间代码生成,生成与机器无关的中间代码
+ 中间代码优化
+ 目标代码生成
有穷状态自动机
DFA和NFA
DFA确定性有穷自动机
    从一个状态转移到相邻的下一个状态只有一条边
NFA非确定性有穷自动机
    从一个状态转移到相邻的下一个状态有多条边,也就是有多个选项
正则匹配两个输入:正则式和待文本串

DFA是拿着文本串取匹配正则式
NFA是拿着正则式取匹配文本串

# 正向预查
## 寻找字符串'Exception'并且该'Exception'后面跟着': 500 Internal Error'
    Exception(?=: 500 Internal Error)
## 寻找字符串'Exception'并且该'Exception'后面不跟着': 500 Internal Error'

    Exception(?!: 500 Internal Error)
# 反向预查
## 寻找字符'a'并且该'a'前面有一个J
    (?<=J)a     匹配J后面的a
## 寻找字符'a'并且该'a'前面没有J
    (?<!J)a     匹配不是J后面的a

+ 匹配开头 ^
+ 匹配字符串结尾 $
+ 匹配单词边界 \b

日期  2012-12-12     2013-04-13,2014-02-12
    ^\\d{4}-[0-1][0-9]-[0-3][0-9](,\\d{4}-[0-1][0-9]-[0-3][0-9])*$
# 获取匹配和非获取匹配
    <h([1-6])>.*?</h\1>
    可以通过\1获取前面匹配到的结果
    
    (?:pattern)	
    匹配 pattern 但不获取匹配结果
也就是说这是一个非获取匹配,**不进行存储供以后使用**

# 贪婪匹配和非贪婪匹配

    ? 当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的
    字符串ooooo
    oo+?将匹配两个o
    oo+尽可能匹配多个o

# 示例

1. 匹配两个连续相同的内容

    '(.)\1' 

2.  匹配img标签:
    <img[\w\W]*?src=[\"|\']?([\w\W]*?)/>
    
3.  匹配img标签中的jpg和png图片
    <img[\w\W]*?src=[\"|\']?([\w\W]*?)(jpg|png)[\w\W]*?/>
    
# 常用正则表达式修饰符
	/g  /i  /m  /s  
+ /g 全局匹配  不加只匹配一个    加了匹配多个
+ /i 不区分大小写  不加大写和小写是不同的    加了不区分大小写
+ /m 多行匹配    不加会将多行当作一个字符串    加了每行都是一个字符串   影响的是^和$两个符号
+ /s 不加.匹配除换行符外的所有字符,加了.可以匹配换行符
	